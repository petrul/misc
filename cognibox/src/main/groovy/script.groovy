import pertinence.cognibox.years.MathYearCodecimport pertinence.cognibox.years.LitteralYearCodecimport pertinence.cognibox.huffman.HuffmanTreeclass PlayWithEncoding {	Map litt_enc_years_map = [:] // litteral encoding does not change so compute it once and for all here	//def year_range = 1000..1300	def year_range = 1000..2100	def math_landmarks = [ : ]	public PlayWithEncoding() {				def litt_landmarks = [ : ]		def litt_hufftree = new HuffmanTree(litt_landmarks)		LitteralYearCodec litt_codec = new LitteralYearCodec(litt_hufftree)		year_range.each { litt_enc_years_map[it] = litt_codec.encode(it) }	}	def run() {				def best_landmark = null		int min_score = Integer.MAX_VALUE				for (candidate_landmark in year_range) {			if (math_landmarks.containsKey(candidate_landmark)) continue;			def tmp_math_landmarks = [ : ]			math_landmarks.each { key, value -> tmp_math_landmarks[key] = value } // copy math landmarks to temporary map			tmp_math_landmarks[candidate_landmark] = 1			def math_hufftree = new HuffmanTree(tmp_math_landmarks)			MathYearCodec math_codec = new MathYearCodec(math_hufftree, 15)			int crt_score = 0			for (year in year_range) {				def math_codes = math_codec.encode(year)				def litt_codes = litt_enc_years_map[year]								List all_encodings = []				math_codes.each {all_encodings << it }				litt_codes.each {all_encodings << it }				//println "$year : $all_encodings"				def score = this.calculateScore(all_encodings)				crt_score += score			}			if (crt_score < min_score) {				min_score = crt_score				best_landmark = candidate_landmark			}			//println "candidate $candidate_landmark : $crt_score "		}				math_landmarks[best_landmark] = 1				//new HuffmanTree(math_landmarks).totallyUnportableSeeGraphvizRepresentation();				println "=" * 40		println "best candidate : $best_landmark with length sum : $min_score, #landmarks = ${math_landmarks.size()}"	}	int calculateScore(List encodings) {		//float score = 0.0		int score = Integer.MAX_VALUE		encodings.each {			if (it.length() <= score)				score = it.length()		}		return score	}	def calculateScoreOld(List encodings) {		double score = 0.0		encodings.each {			def len = it.length()			score += Math.pow(256.0, -len)		}		return score	}}def mainclass = new PlayWithEncoding()20.times { mainclass.run() }println "emerging landmarks : ${mainclass.math_landmarks}"new HuffmanTree(mainclass.math_landmarks).totallyUnportableSeeGraphvizRepresentation();